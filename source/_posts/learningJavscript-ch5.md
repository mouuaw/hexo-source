---
title: CH5 표현식과 연산자
date: 2018-12-23 17:02:00
tags:
- 러닝자바스크립트
---

## 5.1 연산자
연산자는 하나 이상의 피연산자가 있어야 결과를 낼 수 있습니다. 예를들어 1+2 라는 표현식에서 
1, 2 는 피연산자이고 + 는 연산자입니다. 피연산자를 매개변수라 부르는 경우도 있습니다.

## 5.2 산술 연산자

|연산자|설명|예제|
|-------|----|----|
|+|덧셈|3+2 // 5|
|-|뺄셈|3-2 // 1|
|/|나눗셈|3/2 // 1.5|
|*|곱셈|3*2 // 6|
|%|나머지|3%2 // 1|
|-|단항 부정|-x // x의 부호를 바꿈|
|+|단항 플러스|+x // x가 숫자가 아니면 숫자로 변환시도|
|++|전위 증가|++x|
|++|후위 증가|x++|
|--|전위 감소|--x|
|--|후위 감소|x--|

* 자바스크립트의 숫자는 모두 Double 형식이므로 3/2 처럼 정수를 연산한 결과도 더블 형식입니다.

* 단항 부정과 단항 플러스의 경우는 변수에만 사용합니다. 숫자형 리터럴 앞에 붙으면 숫자 리터럴의 일부로 해석되어 연산자가 되지않습니다.

* 위, 후위 연산자의 차이도 이해해야 합니다. 전위 연산자는 연산이 이루어지기 전에 증/감이 이루어지며 후위 연산자는 연산 이후에 증/감이 이루어집니다.

## 5.3 연산자 우선순위

* [https://developer.mozilla.org 참조](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Operators/%EC%97%B0%EC%82%B0%EC%9E%90_%EC%9A%B0%EC%84%A0%EC%88%9C%EC%9C%84#%ED%91%9C)
* 자바스크립트 연산자 우선순위중 가장 높은것이 괄호()입니다.
* 같은 우선순위에선 정의되어있는 순서(오른쪽 -> 왼쪽, 왼쪽 -> 오른쪽) 순서를 따릅니다.

## 5.4 비교 연산자

비교 연산자는 이름처럼 두 개의 값을 비교합니다. 크게 일치함(===), 동등함(==), 대소관계 세 가지 타입으로 나뉩니다.

일치 관계는 같은 객체를 가리키거나, 같은 타입이고 값도 같다면 일치하다고 합니다. 일치관계의 경우 단순하고 이해하기 쉬우므로 버그나 오해를 낳는 경우가 거의 없습니다.

동등 관계는 두 값이 같은 객체를 가리키거나 같은 값을 갖도록 변환할 수 있다면 두 값을 동등하다고 봅니다. 두번째 성질 때문에 수많은 골칫거리와 혼란을 발생시켰는데 예로는 33 == "33" 같은 경우 입니다.

관계 연산자는 관계가 있는 값을 비교하며, 문자열이나 숫자처럼 원래 순서가 있는 데이터 타입에만 사용할 수 있습니다.

## 5.5 숫자 비교

숫자를 비교할 때는 염두해 두어야 할 것이 있습니다.

먼저 특별한 숫자형 값 NaN은 그 자신을 포함하여 무엇과도 같지 않습니다. 즉, NaN === NaN 과 NaN == NaN은 모두 false 입니다. 숫자가 NaN인지 알아보려면 내장된 isNaN 함수를 사용하십시오.

자바스크립트에서 숫자는 모두 Double형식입니다. 그리고 더블 형식은 근사치 이므로, 자바스크립트에서 숫자를 비교하다보면 예상치 못한 결과가 생길때가 있습니다.

자바스크립트에서 정수를 비교할 때, 그 정수가 안전한 범위라면 (Number.MIN_SAFE_INTEGER이상, Number.MAX_SAFE_INTEGER 이하) 안심하고 일치 연산자를 사용할 수 있습니다. 하지만 소수점이 있는 숫자를 비교할 때는 관계 연산자를 써서 테스트 하는 숫자가 대상 숫자에 "충분히 가까운지" 확인하는 편이 좋습니다. 자바스크립트에는 특별한 숫자형 상수 Number.EPSILON이 있습니다. 이것은 매우 작은값(약 2.22e-16)이며, 일반적으로 숫자 두 개를 구별하는 기준으로 사용합니다. 다음 예제를 보십시오.

```javascript
let n = 0;
while(true){
  n += 0.1;
  if(n === 0.3) break;
}
console.log(`Stopped at ${n}`);
```

이 코드를 실행하면 0.3에서 멈추지 않고 무한루프를 돌게됩니다. 이러한 현상이 생기는 이유는 0.1이 더블 형식으로 정확히 나타낼 수 없는 값이기 때문이기 때문입니다. 0.1은 이진 표현으로 나타낼 수 있는 숫자들 사이에 걸쳐 있습니다. 따라서 이 루프를 세 번째 반복할 때 n의 값은 0.30000000000000004 이므로 테스트는 false가 됩니다.

이때 Number.EPSILON과 관계 연산자를 사용해서 '느슨하게' 비교하면 성공적으로 루프를 빠져나갈 수 있습니다.

```javascript
let n = 0;
while(true){
  n += 0.1;
  if(Math.abs(n - 0.3) < Number.EPSILON) break;
}
console.log(`Stopped at ${n}`);
```

## 5.6 문자열 병합

자바스크립트는 피연산자의 타입을 보고 덧셈을 할지 문자열 병합을 할지 판단합니다. 두 피연산자를 왼쪽에서 오른쪽으로 평가한 후, 피연산자 중 하나라도 문자열이면 문자열 병합을 수행합니다.

```javascript
3 + 5 + "8" // 문자열 "88"이 됩니다.
"3" + 5 + 8 // 문자열 "358"이 됩니다.
```

## 5.7 논리 연산자

논리 연산자는 Boolean값만 다룰 수 있습니다. 대부분의 프로그래밍 언어에서 논리 연산자는 불리언 값에서만 동작하며 불리언 값만 반환합니다. 반면 자바스크립트의 논리 연산자는 불리언이 아닌 값도 다룰 수 있고, 놀랍게도 불리언이 아닌 값을 반환하기도 합니다.

연산자에 대해 설명하기 전에 자바스크립트가 불리언이 아닌 값을 불리언 값으로 바꾸는 방법에 익숙해져야 합니다.

### 5.7.1 참 같은 값과 거짓 같은 값

자바스크립트에서는 모든 데이터 타입을 참 같은 값과 거짓 같은 값으로 나눌 수 있습니다.

거짓 같은 값은 다음과 같습니다.

* undefined
* null
* false
* 0
* NaN
* '' (빈 문자열)

이들 외에는 모두 참 같은 값입니다. 참 같은 값은 정말 많으므로 전부 나열할 수 없지만 몇 가지는 염두에 두어야 합니다.

* 모든 객체 valueOf() 메서드를 호출했을 때 false를 반환하는 객체도 참 같은 값에 속합니다.
* 배열, 빈 배열도 참 같은 값에 속합니다.
* 공백만 있는 문자열 ("  ")등
* 문자열 "false"

## 5.8 AND, OR, NOT

자바스크립트가 지원하는 논리 연산자는 AND(&&), OR(||), NOT(!) 세 가지 입니다. 

### 5.8.1 단축 평가

AND연산의 경우 두 값을 모두 평가하지 않아도 될 때가 있습니다. x && y 에서 x가 false 라면 y는 평가할 필요없이 연산의 결과는 false 입니다. 자바스크립트는 이런 방식으로 동작하며 이것을 단축 평가 라고 합니다.

```javascript
const skipIt = true;
let x = 0;
const result = skipIt || x++;
```

위 연산에서 재밋는 점은 skipIt이 true 이므로 x++ 이 연산되지 않고 지나간다는 점 입니다.
x++ 연산을 동작 시키려면 skipIt이 false가 되면 됩니다.

```javascript
const doIt = false;
let x = 0;
const result = doIt && x++;
```

여기에선 더 재미있는 현상이 일어납니다. doIt이 false 일 경우 x++연산이 스킵되지만 doIt이 true이면 x++연산이 일어납니다. 
하지만 result에 저장되는 값은 true가 아닌 0이 들어가게 됩니다.
이렇게 동작하는 이유를 알기위해선 피연산자가 불리언이 아닐 때 논리연산자가 동작하는 방법을 알아야 합니다.

### 5.8.2 피연산자가 불리언이 아닐 때 논리 연산자가 동작하는 방법

불리언 피연산자를 사용하면 논리 연산자는 항상 불리언을 반환합니다. 피연산자가 불리언이 아니면, 결과물을 결정한 값이 반환됩니다.

|x|y|x && y|
|--|--|--|
|거짓 같은 값|거짓 같은 값|x(거짓 같은 값)|
|거짓 같은 값|참 같은 값|x(거짓 같은 값)|
|참 같은 값|거짓 같은 값|y(거짓 같은 값)|
|참 같은 값|참 같은 값|y(참 같은 값)|


|x|y|x or y|
|--|--|--|
|거짓 같은 값|거짓 같은 값|y(거짓 같은 값)|
|거짓 같은 값|참 같은 값|y(참 같은 값)|
|참 같은 값|거짓 같은 값|x(참 같은 값)|
|참 같은 값|참 같은 값|x(참 같은 값)|

이런 자바스크립트의 특징을 이용한 몇가지 코딩 트릭이 있습니다.

```javascript
const options = suppliedOptions || {name: "Default"}
```

객체는 빈 값이어도 항상 참 같은 값으로 평가됩니다. 따라서 suppliedOptions가 객체이면 options는 suppliedOptions를 가리키게 됩니다. 옵션이 제공되지 않으면, 즉 suppliedOptions가 null이나 undefiend라면 options는 기본값을 갖게 됩니다.

### 5.8.3 조건 연산자

조건 연산자는 자바스크립트의 유일한 3항 연산자 입니다. 조건 연산자는 if...else 문과 동일한 표현식 입니다. 다음 예제를 보십시오

```javascript
const doIt = false;
const result = doIt ? "Did it!" : "Didn't do it.";
```

3항 연산자를 if...else 문을 혼란스럽게 바꿔 놓은것이 아니냐는 식으로 생각할 수 있지만, 3항 연산자는 문이 아니라 표현식이므로 다른 표현식과 결합하여 매우 유용하게 사용할 수 있습니다.

### 5.8.4 쉼표 연산자

쉼표 연산자는 표현식을 결합하여 두 표현식을 평가한 후, 두 번째 표현식의 결과를 반환합니다.
표현식을 하나 이상 실행해야 하지만 값으로 필요한 것은 마지막 표현식의 결과뿐일 때 쉼표 연산자를 유용하게 쓸 수 있습니다.

```javascript
let x = 0, y = 10, z;
z = (x++, y++);
```

이 예제에서 x,y 의 값은 1씩 증가하지만 z의 값은 10, 즉 y++가 반환하는 값입니다. 쉼표 연산자는 우선순위가 가장 낮은 연산자 이므로 괄호를 사용했습니다. 쉼표 연산자는 for 문에서 표현식을 결합할 때 사용하거나, 함수에서 빠져나오기 전에 여러 가지 작업을 한데 묶을 때 사용합니다.

## 5.9 연산자 그룹

그룹 연산자(괄호)에는 아무 효과도 없지만 연산자 우선순위를 높이거나 명확히 표현하는데 쓸 수 있습니다. 따라서 그룹 연산자는 연산 순서만 바꿀 뿐, 다른 부작용은 전혀 없는 안전한 연산자 입니다.

### 5.9.1 비트 연산자

비트 연산자는 피연산자를 2의 보수 형식으로 저장된 32비트 부호 붙은 정수로 간주합니다. 자바스크립트의 숫자는 모두 더블 형식이므로 자바스크립트는 비트 연산자를 실행하기 전에 숫자를 먼저 32비트 정수로 변환하고, 결과를 반환할 때 다시 더블 형식으로 변환합니다.

(마크다운 문법때문에 | 를 (or) 로 표기함)

|연산자|설명|예제|
|--|--|--|
|&|비트 AND|0b1010 & 0b1100 // 결과: 0b1000|
|(or)|비트 OR|0b1010 (or) 0b1100 // 결과: 0b1110|
|^|비트 XOR|0b1010 ^ 0b1100 // 결과: 0b0110|
|~|비트 NOT|-0b1010 // 결과: 0b0101|
|<<|왼쪽 시프트||
|>>|부호가 따라가는 오른쪽 시프트||
|>>>|0으로 채우는 오른쪽 시프트||

왼쪽 시프트는 2를 곱하는 효과가 있고, 오른쪽 시프트는 2로 나눈 다음 소수점 아래를 버리는 효과가 있습니다.
하드웨어 조작을 제외하고 비트 연산자를 쓰는 것이 효율적인 경우는 플래그(불리언 값)을 다룰때 입니다.

유닉스에서는 파일에 읽기, 쓰기, 실행 권한을 각각 지정할 수 있습니다. 사용자 마다 이들 권한이 각각 주어질 수 있으므로 플래그를 사용하는 것이 어울립니다. 플래그가 세 개 있으므로 이 정보를 저장하는 데는 비트 세 개가 필요합니다.

```javascript
const FLAG_EXECUTE = 1 // 0b001
const FLAG_WRITE = 2 // 0b010
const FLAG_READ = 4 // 0b100
```

### 5.9.2 typeof 연산자

typeof 연산자는 피연산자의 타입을 나타내는 문자열을 반환합니다. 하지만 이 연산자는 자바스크립트의 일곱가지 데이터 타입을 정확하게 나타내지 못하며 끝없는 혼란을 초래했고 계속 비판받았습니다.

다음은 typeof가 반환할 수 있는 값입니다.

|표현식|반환값|참고|
|--|--|--|
|typeof undefined|"undefined"||
|typeof null|"object"|애석하지만 사실입니다.|
|typeof {}|"object"||
|typeof true|"boolean"||
|typeof 1|"number"||
|typeof ""|"string"||
|typeof Symbol()|"symbol"|ES6에서 새로 생겼습니다.|
|typeof function(){}|"function"||

### 5.9.3 void 연산자

void 연산자는 undefined를 반환합니다. 잘 쓰이진 않지만 다음과 같은 방법으로도 사용 가능합니다

```html
<a href="javascript:void 0">Do nothing.</a>
```

### 5.9.4 할당 연산자

할당 연산자는 변수에 값을 할당해야 합니다. 그렇기 때문에 표현식의 좌변에 있는 것은 반드시 값을 저장할 수 있는 것이어야 합니다.

## 5.10 해체 할당

ES6에서 새로 도입한 해체 할당은 매우 환영 받는 기능입니다. 이 기능은 객체나 배열을 변수로 '해체'할 수 있습니다.

```javascript
// 객체 선언
const obj = {b:2, c:3, d:4};

// 해체 할당
const {a, b, c} = obj;

a; // undefind
b; // 2
c; // 3
d; // ReferenceError
```

객체를 해체할 때는 반드시 변수 이름과 객체의 프로퍼티 이름이 일치해야 합니다. 프로퍼티 이름이 유효한 식별자인 프로퍼티만 해체 후 할당됩니다.

이 예제에서는 선언과 할당을 같은 문에서 실행했습니다. 객체 해체는 할당만으로 이뤄질 수도 있지만, 그렇게 하려면 반드시 괄호를 써야합니다. 괄호를 쓰지 않으면 자바스크립트는 표현식 좌변을 블록으로 해석합니다.

```javascript
const obj = {b:2, c:3, d:4};
let a, b, c;

// 에러가 납니다.
{a, b, c} = obj;

// 동작합니다.
({a, b, c} = obj);
```

배열을 해체할 때는 배열 요소에 대응할 변수 이름을 마음대로 쓸 수 있으며 이들은 배열 순서대로 대응합니다.

```javascript
// 배열 선언
const arr = [1,2,3];

// 배열 해체 할당
let [x, y] = arr;
x; // 1,
y; // 2,
z; // ReferenceError
```

확산 연산자(...)를 사용하면 남은 요소를 새 배열에 할당할 수 있습니다.

```javascript
const arr = [1,2,3,4,5];

let [x, y, ...rest] = arr;

x; // 1
y; // 2
rest; //[3,4,5]
```

배열 해체를 활용한 변수 값 교환도 유용하게 쓸 수 있습니다.

```javascript
let a = 5, b = 10;
[a,b] = [b,a];
a; // 10
b; // 5
```

## 5.11 객체와 배열 연산자

객체와 배열, 함수에는 특별한 연산자가 있습니다. 이러한 연산자는 해당 챕터에서 자세히 설명되어 있습니다.

## 5.12 템플릿 문자열과 표현식

템플린 문자열은 어떤 표현식이든 그 값을 문자열에 넣을 수 있습니다.

```javascript
const roomTempC = 21.5;
let currentTempC = 19.5;
const message = `The current temperature is ` +
  `${currentTempC - roomTempC}\u00b0 different than room temperature.`;
const fahrenheit = 
  `The current temperature is ${currentTempC * 9/5 + 32}\u00b0F`;
```

## 5.13 표현식과 흐름 제어 패턴

### 5.13.1 if...else 문을 3항 연산자로 바꾸기(생략)
### 5.13.2 if 문을 단축 평가하는 OR 표현식으로 바꾸기

```javascript
if(!options) options = {}

// 이처럼 바꿀 수 있습니다.
options = options || {};
```